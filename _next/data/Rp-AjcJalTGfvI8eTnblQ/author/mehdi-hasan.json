{"pageProps":{"author":"Mehdi Hasan","posts":[{"slug":"is-something-dramatic-happening-underground-in-bangladesh","title":"Is Something Dramatic Happening Underground in Bangladesh? A Data-Based Look at Earthquakes","date":"2025-12-04","tags":["Data","Science"],"coverImage":"/images/eqb/earthquake_animation.gif","author":"Mehdi Hasan","content":"\nRecent weeks have raised public concern in Bangladesh after several noticeable earthquakes shook the Dhaka–Narsingdi region. Many people are wondering: *Is this the start of something dangerous? Has seismic activity suddenly increased?* To answer these questions, we analyzed decades of earthquake data across Bangladesh and compared it with the events of 2025. Here is what the numbers — not rumors — actually show.\n\n## **What the long-term data tells us**\n\nA full historical catalog of 465 earthquakes (1976–2025) shows that Bangladesh experiences regular moderate seismicity. The recent activity sits within long-term patterns, but several features of **2025 stand out scientifically**:\n\n### **Energy release in 2025 is higher than average**\n\nThis year’s events have released about **1.65× more seismic energy** than the historical yearly average. That increase is driven mainly by the **M5.4 earthquake on November 21**, the largest event of the year.\n\n![img](/images/eqb/seismic_eng_per_yr.png)\n\n### **Event counts are *not* unusually high**\n\nStatistical tests show that **2025 has a normal number of earthquakes** — no spike in the *frequency* of events.\n\n![img](/images/eqb/e_count.png)\n\n### **Magnitudes remain in the typical range**\n\nThe distribution of earthquake magnitudes in 2025 does **not differ significantly** from previous decades.\n\n![img](/images/eqb/mag_distribution.png)\n\n![img](/images/eqb/mag_bin.png)\n\n### **Depth is where things get interesting**\n\nMultiple tests show that **2025 earthquakes are noticeably shallower** than in most previous years. Shallow earthquakes are felt more strongly at the surface, even if their magnitudes are moderate.\n\n![img](/images/eqb/median_quake_depth.png)\n\nThis is one of the most important findings: **No unusual increase in the number of earthquakes — but the ones occurring are shallower, so they feel stronger.**\n\n![img](/images/eqb/depth_dis.png)\n\n## **Understanding the recent sequence near Dhaka / Narsingdi**\n\nSo far, four earthquakes attracted public attention in late November and early December:\n\n| Date (UTC) | Mag | Depth | Location        |\n|------------|-----|-------|-----------------|\n| Nov 21     | 5.4 | 27 km | Narsingdi (SSW) |\n| Nov 22     | 4.3 | 10 km | Narsingdi (W)   |\n| Nov 27     | 4.0 | 10 km | Tungi (NNE)     |\n| Dec 4      | 4.1 | 10 km | Dhaka (ESE)     |\n\nThe **21 November M5.4 earthquake** is almost certainly the **mainshock**, assuming no larger event occurred shortly before or after it. Terms like *mainshock* or *foreshock* are assigned **after** the fact, once the full sequence is known. The three subsequent earthquakes — magnitudes **4.0 to 4.3** over the following two weeks — fit the pattern of **aftershocks**, which is the normal and expected response of the crust after a moderate event like this.\n\nAftershock models and cluster analysis support this:\n\n- Spatially close\n- Shallow\n- Occurred soon after the M5.4\n- Magnitudes appropriate for aftershocks\n\nThere is **no scientific indication** that the sequence is an \"ongoing mega-event\" or a sign of an imminent major catastrophe.\n\n![img](/images/eqb/quake_clusters.png)\n\n## **Should people be worried?**\n\n### **Short answer: No panic — but yes, be prepared.**\n\nBased on the data:\n\n- There is **no evidence** of a large earthquake building up in the immediate future.\n- The pattern fits a **normal mainshock–aftershock sequence**.\n- Bangladesh’s long-term seismic environment is active, but this year is not unprecedented.\n\nThat said, shallow earthquakes, even at moderate magnitudes, can **shake cities hard**, especially in cities like Dhaka with probably thousands of vulnerable buildings. This means:\n\n- **Risk exists**\n- **But it is manageable**\n- **Preparedness is the key difference-maker**\n\n## **Why shallow earthquakes matter more**\n\nOur analysis found a statistically significant shift toward shallower depths in 2025. This is important because:\n\n- A shallow M4–M5 can feel like a deeper M6 in terms of surface shaking.\n- Dhaka has many old and unreinforced structures that are more sensitive to this kind of shaking.\n- Even without a major earthquake, shallow moderate events can cause injuries, wall collapses, and infrastructure disruption.\n\nSo the message is not \"a big earthquake is coming.\"\nThe message is: **a moderate earthquake can still be damaging if buildings are fragile — so strengthen preparedness now.**\n\n## **What people and communities can do right now**\n\n### **A. Stay informed without panic**\n\nFollow official bulletins from:\n\n- Bangladesh Meteorological Department (BMD)\n- National Disaster Response agencies\n- Universities or credible institutions\n\n**Please avoid unverified social media rumors.**\n\n### **B. Community organization**\n\n- Form **local volunteer preparedness groups** in neighborhoods.\n- Identify safe open spaces.\n- Help elderly or disabled neighbors with emergency planning.\n- Practice evacuation routes.\n\n### **C. Training and drills**\n\nPush local authorities and community leaders to:\n\n- Organize **earthquake safety workshops**.\n- Conduct **drop–cover–hold-on drills** in schools, offices, and markets.\n- Teach people how to check homes for hazards (loose shelves, falling objects, unsecured gas cylinders).\n\n### **D. Structural safety**\n\nCitizens and journalists should push authorities to:\n\n- Enforce building codes more strictly.\n- Inspect vulnerable buildings, especially schools and hospitals.\n- Provide public guidance on strengthening old structures.\n\n### **E. Spread helpful information**\n\nLocal organizations can print simple, factual pamphlets covering:\n\n- What to do during shaking\n- How to prepare emergency kits\n- Where to gather after an earthquake\n- How aftershocks behave\n- What NOT to believe on social media\n\nHelping people understand what is normal in an earthquake sequence reduces fear — and that improves safety.\n\n## **Final takeaway**\n\n**No, Bangladesh is not currently experiencing a dramatic, unprecedented seismic crisis.**\nBut **yes**, 2025’s earthquakes — especially the shallow M5.4 near Narsingdi — remind us that Bangladesh sits in an active tectonic region where moderate earthquakes can be strongly felt.\n\n- The number of earthquakes is normal.\n- Magnitudes are normal.\n- **Depths are shallower**, so shaking feels stronger.\n- The recent events fit a **mainshock–aftershock pattern**.\n- Preparedness, not panic, is the appropriate response.\n\nEarthquakes cannot be stopped, but **knowledge, training, and readiness** can prevent injuries and save lives. The best time to prepare is **before** a larger earthquake happens — and these recent events give Bangladesh a valuable opportunity to do exactly that.\n\nFor those interested in the full analysis, code, and data, it is available on [this GitHub repository](https://github.com/mehdihasan/bd-earthquake-analysis-2025).\n\n## Verified Sources Covering 2025 Earthquake\n\n1. [No, Dhaka Is Not At Risk of a 9.0 Earthquake That Would Liquefy the City](https://counterpointbd.substack.com/p/no-dhaka-is-not-at-risk-of-a-90-earthquake) by Asifur Rahman Khan\n2. [The Latest Earthquake Was a Warning Sign: Bangladesh Isn’t Ready](https://thediplomat.com/2025/12/the-latest-earthquake-was-a-warning-sign-bangladesh-isnt-ready) by Thomas L. Davis\n"},{"slug":"fixing-concurrent-queries-within-the-same-session-in-clickHouse-async-python-apps","title":"Fixing Concurrent Queries Within the Same Session in ClickHouse Async Python Apps (Uvicorn + FastAPI)","date":"2025-10-16","tags":["Python","ClickHouse","Uvicorn","Concurrency","Architecture","DevOps"],"coverImage":"/images/ch1/cover.jpg","author":"Mehdi Hasan","content":"\nConnecting to a database from Python seems simple enough - you create a client, send queries, and handle results. But when we scaled that to thousands of concurrent requests under an async web server, things got a bit more interesting.\n\nThis post walks through how we hit a classic concurrency issue in our ClickHouse integration - how it appeared, what caused it, the quick fix we applied, and finally how we designed a long-term scalable solution using an async connection pool.\n\n## The Setup\n\nOur backend service is a data ingestion API that pushes concurrent large JSON payloads into ClickHouse. It runs on top of [**Uvicorn**](https://uvicorn.dev/), an ASGI web server that handles requests asynchronously.\n\nWe used the official [clickhouse-connect](https://github.com/ClickHouse/clickhouse-connect) library to communicate with the database. In the beginning, the design looked clean and simple:\n\n```python\n# Simplified version of the initial design\n\nclass CB:\n\n    def __init__(self):\n        self.client = AsyncClient(\n            host=\"clickhouse_host\",\n            port=8123,\n            database=\"DB_NAME\",\n            username=\"default\",\n            password=\"default\"\n        )\n\n    async def post_raw(self, payload):\n        await self.client.insert(table=\"m_data\", data=payload)\n```\n\nWe created **a single AsyncClient instance** when the backend started - a singleton pattern. Every request reused this same client to perform queries, inserts and health checks.\n\nWe leveraged [ClickHouse's server-side asynchronous insert](https://clickhouse.com/docs/optimize/asynchronous-inserts) feature by configuring the insertion settings to use ***async_insert=1***. This setting is key for high-throughput ingestion, as it tells the [ClickHouse server to buffer and batch data internally](https://clickhouse.com/blog/asynchronous-data-inserts-in-clickhouse). However, as we soon discovered, server-side data handling being asynchronous does not guarantee client-side session safety.\n\n## The Problem Appears\n\nEverything was smooth in development and staging environments. It looked fine - until we hit production and started ingesting thousands of rows per minute, the logs exploded with the following message:\n\n> ***Attempt to execute concurrent queries within the same session. Please use a separate client instance per thread/process.***\n\nThirty percent of the inserts began failing randomly under load. Some succeeded, others didn't. It wasn't deterministic - but it was bad.\n\n## The Role of Uvicorn and Async Concurrency\n\nOur API application runs on **Uvicorn** web server, which means requests are handled *asynchronously* on a single [event loop](https://uvicorn.dev/concepts/event-loop/) by the [*uvloop* library](https://github.com/MagicStack/uvloop).\n\nIn async Python, multiple [coroutines](https://docs.python.org/3/library/asyncio-task.html) (i.e., concurrent requests) share the same event loop and can all run at once when waiting on I/O. So even though we weren't using multiple OS threads (no parallelism), we achieved high concurrency within the same single-threaded process by efficiently switching between waiting requests.\n\nHere's what was happening under the hood:\n\n![img](/images/ch1/image_1.jpg)\n\nBecause all requests used the **same Clickhouse AsyncClient instance**, multiple coroutines tried to send different queries over the same underlying TCP session - at the same time. This scenario is a classic example of shared mutable state in an asynchronous environment. Multiple requests raced to use the same underlying socket before the previous query had finished, violating the database client's contract.\n\nClickHouse rightfully rejected this pattern. Its client session protocol doesn't support multiple concurrent queries per connection. Each query must complete before another begins on the same connection.\n\nIt's important to distinguish between ClickHouse's server-side asynchronous insert feature (async_insert=1) and our client-side asynchronous concurrency (Uvicorn/coroutine model). The server-side feature efficiently buffers the data. However, the client driver still requires a non-conflicting network session to send the insert request and receive the response (even if that response is a quick acknowledgement). Our problem was that multiple coroutines were attempting to initiate their separate insert operations over the single shared client session at the exact same moment, which the client/session protocol disallowed. The fix was necessary to resolve the session-level concurrency issue, not the server's data-buffering mechanism.\n\nThat's why the error message said:\n\n> ***Please use a separate client instance per thread/process.***\n\nEven though we weren't using multiple threads, we had the same effect: concurrent use of a shared connection.\n\n## Quick Fix: One Client per Request\n\nWhen production fire alarms are ringing, elegance comes second.\n\nAs a **quick fix**, we changed our approach to create a **new ClickHouse client per request**.\n\n```python\nasync def post_data(self, payload):\n    async with AsyncClient(client=get_client(...)) as client:\n        await client.insert(...)\n```\n\nThat immediately solved the concurrency issue. Each request had its own isolated client - and therefore its own TCP session - avoiding shared-state problems completely.\n\nBut this (and probably most) quick solution came at a cost.\n\nCreating and closing a ClickHouse client for every single request is expensive. At large ingestion volumes, it increases connection setup overhead, authentication latency, and CPU churn on both the client and server sides.\n\nWe needed something more efficient.\n\n## The Final Fix: Connection Pooling\n\nOnce stability returned, we revisited the design.\n\nInstead of one global client or one-per-request, we moved to a **connection pool** - maintaining a fixed number of ready-to-use ClickHouse clients and reusing them efficiently.\n\n![img](/images/ch1/image_2.jpg)\n\n### New approach\n\n```python\nclass PooledClient:\n    \"\"\"Helper Context Manager Class\"\"\"\n\n    def __init__(self, pool, client):\n        self._pool = pool\n        self.client = client\n\n    async def __aenter__(self):\n        \"\"\"Called when 'async with' starts\"\"\"\n        return self.client\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"\n        Called when 'async with' block ends (even on error).\n        For simplicity, we just return the client to the pool.\n        (You could add logic here to replace broken clients.)\n        \"\"\"\n        if not getattr(self.client, \"is_closed\", False):\n            await self._pool.put(self.client)\n        return False\n\n\nclass ClickhousePool:\n    \"\"\"Main Connection Pool Class\"\"\"\n\n    def __init__(self):\n        self._pool = asyncio.Queue(maxsize=SIZE)\n        for _ in range(SIZE):\n            client = AsyncClient(client=get_client(...))\n            self._pool.put_nowait(client)\n\n    async def get_client(self):\n        \"\"\"Returns a context manager object that handles the client lifecycle\"\"\"\n        return PooledClient(self._pool, await self._pool.get())\n\n    async def post_data(self, payload):\n        \"\"\"The Clean Consumption in the API\"\"\"\n        rows = ...  # transformations of payload\n        table_name = ...\n        columns = ...\n\n        async with self.get_client() as client:\n            await client.insert(\n                table=table_name,\n                data=rows,\n                column_names=columns,\n                settings={\n                    'async_insert': 1,\n                    'wait_for_async_insert': 0,\n                    # ... other settings\n                }\n            )\n```\n\nOnce the connection pool is in place, usage of async API is straightforward:\n\n```python\ncp = ClickhousePool()\nawait cp.post_data(payload)\n```\n\nWith the pooled design we make sure that, (1) each of the requests borrow a client from the pool, (2) they use it to execute a query or insert, (3) the client is released back into the pool afterward, (4) if a client breaks (due to a network or protocol error), it's replaced with a new one.\n\nThis hybrid approach provides safety by not sharing clients across concurrent requests, performance by avoiding recreate clients repeatedly, scalability by easily tune pool size to match workload.\n\n```txt\nSingleton        ->  One global AsyncClient\nPer-request      ->  New client per request\nConnection pool  ->  Limited shared pool, reused safely\n```\n\n## Validation and Results\n\nOnce deployed, the difference was clear.\n\nWe validated the new behavior in three ways. Error messages related to ***concurrent queries within the same session*** disappeared completely. Connection metrics stabilized - fewer reconnections, more consistent query latencies. The ClickHouse row count graphs started growing linearly again - confirming ingestion pipelines were back to full capacity.\n\n## Lessons Learned\n\nOne of the key takeaways from this experience was realizing that asynchronous code isn't automatically thread-safe or concurrency-safe. Using async functions doesn't guarantee that shared resources can be accessed safely by multiple coroutines. In our case, reusing a single AsyncClient across concurrent requests seemed fine at first, but when multiple coroutines tried to use it simultaneously, it led to unexpected failures. The event loop can rapidly switch between these coroutines, and if the underlying resource isn't designed for concurrent access, it will eventually break - exactly as we saw with the ClickHouse client.\n\nWe also learned that Uvicorn's speed comes from concurrency, not parallelism. It multiplexes many requests on a single event loop in one process. That means even though the server feels lightweight and fast, all those requests are sharing the same runtime environment. Any global object - such as a database connection, HTTP session, or cache client - must be carefully managed to ensure it's concurrency-safe. The illusion of simplicity in async code can be deceptive; behind the scenes, coroutines are continuously yielding and resuming, which magnifies issues caused by shared mutable state.\n\nWhen production problems strike, it's often tempting to apply quick fixes to restore stability. We did the same by creating one client per request - a brute-force but effective short-term solution. It isolated each operation and immediately eliminated concurrency conflicts. However, that approach didn't scale well. Each new client meant an additional connection handshake, authentication cycle, and network setup overhead. It worked to stop the bleeding, but it wasn't efficient enough for a high-throughput ingestion system. A connection pool, on the other hand, gave us the right balance - isolation without excessive overhead.\n\nFinally, this journey reinforced that observability is critical. Without clear logs, metrics, and dashboards, it would have been nearly impossible to pinpoint the root cause or verify the effectiveness of our fix. Our Grafana dashboards, error logs, and ClickHouse ingestion metrics made it clear when the issue appeared, how severe it was, and how things stabilized after deploying the pooled solution. Good observability turned what could have been a long debugging marathon into a structured diagnosis and validation process.\n\n## Closing Thoughts\n\nThis issue was a great reminder that even high-level async code hides some deep concurrency challenges underneath.\n\nThe evolution - from a single shared client, to per-request isolation, to an efficient async connection pool - illustrates how understanding the **runtime model** (Uvicorn + async I/O) is just as important as writing correct business logic.\n"}]},"__N_SSG":true}