{"pageProps":{"tag":"Software Engineering","posts":[{"slug":"a-new-architecture-is-emerging-inside-the-agentic-ai-shift-in-software-engineering","title":"A New Architecture Is Emerging: Inside the Agentic AI Shift in Software Engineering","date":"2025-12-8","tags":["AI Agents","Software Engineering","Multi-Agent Systems","System Design"],"coverImage":"/images/agents/cover.jpg","author":"Mehdi Hasan","content":"\nA few days ago, I had the opportunity to attend an [**5-Day AI Agents Intensive Course with Google**](https://www.kaggle.com/learn-guide/5-day-agents) arranged by Kaggle in collaboration with Google. Today, I want to share what the course covered, what I learned, and why I believe agentic systems are going to shape the future of software development.\n\n## The Course Structure\n\nThe course was organized into **five modules across five days**, each focused on one core pillar of agentic AI development. Every day included a rich set of learning materials: a summary podcast, a detailed whitepaper, hands-on codelabs in Python using ADK, and a one-hour YouTube livestream featuring managers, engineers, and researchers from Google discussing the day’s topic. This blend of theory, practice, and expert insight made the learning experience both deep and practical.\n\n### **Day 1: Introduction to AI Agents**\n\nThe first day laid the foundation. We explored what AI agents are, why they matter, and how they differ from standalone LLM applications. Using the Agent Development Kit, we built our very first agent - and even a simple multi-agent system. It was surprisingly approachable: a bit of Python, some orchestration, and an LLM under the hood.\n\nThe accompanying whitepaper introduced a taxonomy of agent capabilities and emphasized the importance of **AgentOps**, reliability, governance, and secure interoperability using identity and constrained policies.\n\nIn the codelabs, we built a basic agent powered by Gemini, and a small multi-agent system capable of using Google Search for real-time information retrieval.\n\nThese early exercises highlighted the power of combining reasoning (LLMs) with tools and structured workflows.\n\n### **Day 2: Building Tools for Agents**\n\nDay two focused on the tool ecosystem that enables agents to act rather than just reason. We learned how [MCP](https://modelcontextprotocol.io/docs/getting-started/intro) servers and standardized protocols let agents call external APIs, retrieve real-time data, and perform actions that go beyond the LLM’s training data.\n\nThe whitepaper covered best practices for designing high-quality tools and introduced the architecture, communication layers, and enterprise-readiness considerations of MCP.\n\nIn the codelabs, we converted Python functions into tools agents could call, built custom MCP-based capabilities, and implemented long-running tool operations where an agent pauses execution and requests human approval before continuing.\n\n### **Day 3: Context Engineering**\n\nThe third module was all about giving agents **memory**, continuity, and personalization. We explored how context engineering enables agents to maintain working memory within a session and persist long-term memory across sessions - crucial for multi-step or long-running tasks.\n\nThe whitepaper introduced “Sessions” as the container for immediate conversational history and “Memory” as the persistence layer for long-term state retention.\n\nThe codelabs demonstrated how to manage conversation history in ADK, enable multi-turn reasoning, and give agents long-term memory that survives across different interactions.\n\nBy the end of the day, agents felt more like persistent digital assistants rather than single-request responders.\n\n### **Day 4: Reliability and Observability**\n\nThis module addressed one of the most important challenges in AI engineering: ensuring agents behave predictably and transparently. We explored logging, tracing, metrics, and evaluation methods to monitor agent behavior and manage costs over time.\n\nThe whitepaper presented a comprehensive evaluation framework built on:\n\n* **Logs** (the diary),\n* **Traces** (the narrative), and\n* **Metrics** (the health report),\n\nand discussed scalable evaluation techniques like LLM-as-a-Judge and Human-in-the-Loop(HITL) workflows.\n\nIn the codelabs, we learned to debug agent behavior using detailed logs and traces, understand why an agent made a particular decision, and evaluate the quality of responses and tool usage using structured scoring methods.\n\nThis day provided the essential “production mindset” needed for trustworthy deployment.\n\n### **Day 5: Production-Grade Multi-Agent Systems**\n\nThe final module brought everything together. We moved from prototypes to production-ready architecture, learning how to design scalable systems composed of multiple cooperating agents.\n\nThe whitepaper explored the operational lifecycle of enterprise-grade agents, focusing on deployment, scaling, and the **Agent2Agent (A2A) protocol**, which enables agents to communicate and collaborate directly with other agents.\n\nIn the codelabs, we: built multi-agent systems using A2A, enabled agents to exchange messages and delegate tasks, and deployed an agent to the **Vertex AI Agent Engine** to run as a scalable service on Google Cloud.\n\nThis was the moment where all the concepts matured into a clear picture of how a team of agents can function like specialized human teams - each agent doing its part to achieve a complex collective goal.\n\n## The Tech Stack Behind the Agents\n\nFrom a software engineering perspective, the technology wasn’t entirely new.\nThe course relied on:\n\n* Jupyter Notebooks\n* Python\n* MCP client–server architecture\n* API and protocol design\n* Logging, tracing, and metrics\n* Databases for storing context and memory\n\nWhat stood out as new was the ADK (Agent Development Kit). It functions much like the SDKs we’ve seen in other technology ecosystems - Android, iOS, cloud frameworks, and more. ADK provides a structured environment for defining agent behavior, attaching tools, and connecting agents to LLMs securely through API keys.\n\n## How AI Agents Actually Work\n\nLLMs, by themselves, can only reason over the information they’ve been trained on. They cannot take actions, fetch real-time data, or call external systems.\nAgents bridge this gap.\n\nThey extend an LLM’s capabilities by:\n\n* gathering fresh, real-world information through tools,\n* executing functions or programs,\n* performing calculations,\n* calling APIs,\n* searching the internet, and\n* feeding the results back into the LLM for analysis.\n\nIn this model, the **LLM acts as the reasoner** - interpreting goals, understanding context, and making decisions - while the **agent functions as the executor**, carrying out steps, coordinating tools, and managing workflows.\n\nThis separation of roles is what allows complex, multi-step, and even multi-agent systems to function reliably and continuously, far beyond what a standalone LLM can achieve.\n\n## A Practical Example: Content Creation With Agents\n\nConsider something as common as producing a full article. Traditionally, this involves several steps:\n\n1. researching the topic,\n2. gathering reference material,\n3. structuring and drafting the piece,\n4. creating visuals,\n5. editing and refining,\n6. and finally publishing it.\n\nA process like this usually demands hours of focused work - or the coordination of multiple people.\n\nWith agents, this workflow can be split into a team of specialists working together:\n\n* a **research agent** gathering reliable contemporary information,\n* a **title and SEO agent** generating headlines and keywords,\n* a **drafting agent** turning findings into structured content,\n* an **image-generation agent** creating visuals,\n* an **editor agent** refining clarity and tone,\n* and a **publishing agent** formatting and posting the final piece.\n\nEach agent has a narrow responsibility, similar to microservices in software systems. This orchestration - driven by an LLM as the “reasoner” and powered by tools as the “executors” - lets machines automate large, multi-step creative workflows with a level of coordination that was never practical before.\n\nWhat’s interesting is how this reflects a broader industry shift.\n\n## My Final Project: Smart Property Discovery\n\nFor the course project, I built a multi-agent system that helps users find housing properties matching their preferences.\n\nHere’s how it worked:\n\n* One agent scraped property data from different sources.\n* Specialized tools calculated features such as distance to the nearest station, water body, or bus stop.\n* Another agent evaluated whether a property met the client’s requirements.\n* If a property scored above a certain threshold, a notification agent emailed the user.\n\nThis solution saved significant time in manually filtering through endless property listings - a perfect example of real-world value from agentic systems.\n\n## The Future of Work: What’s About to Shift?\n\nWorking through these agent-driven workflow patterns makes it obvious how quickly automated systems are moving from experimental to foundational. I think the shift isn’t about replacing individual tasks here and there - it’s about restructuring *how* work gets done.\n\n### Where Automation Will Accelerate\n\nThe workflows denoted in the course - sequential pipelines, parallel research teams, refinement loops - highlight the kinds of tasks that are first-class for automation:\n\n* processes built on repeatable, well-defined steps,\n* information gathering that scales with volume,\n* decisions shaped by consistent rules rather than deep judgment,\n* work that benefits from predictable execution over creativity.\n\nThese are exactly the domains where agents outperform traditional manual approaches.\n\n### Roles That Will Grow, Not Shrink\n\nIn my opinion, as systems will become increasingly agentic, entirely new categories of work will emerge around:\n\n* designing and composing complex agents,\n* building custom tools and function interfaces,\n* maintaining long-running agent systems,\n* orchestrating workflows across sequential, parallel, and loop structures,\n* monitoring and debugging multi-agent pipelines.\n\nWe’re moving toward a world where “agent engineer” or “workflow orchestrator” becomes as common a title as “backend developer” is today.\n\nGiven the current trajectory, it's reasonable to expect broad adoption within the next **5–10 years**, not because AI is “taking over,” but because organizations will automate any process that can be reliably broken into agent-friendly steps. In fact, I am starting to see this happening in the organization I work for, right in front of my own eyes.\n\nFor anyone entering software development now, learning to architect and operate agent systems will be a career advantage for sure.\n\n### A New Development Ecosystem Taking Shape\n\nOne of the clearest insights from the course is that we’re watching a new platform era begin. Major companies aren’t just releasing models - they’re introducing full ecosystems for agent construction.\n\nGoogle’s stack is a prime example: the Gemini models, the [Agent Development Kit (ADK)](https://google.github.io/adk-docs/), workflow-specific agent types (Sequential, Parallel, Loop), custom tools, and orchestration layers. This ecosystemization is familiar in tech:\n\n* Android → Android SDK\n* iOS → Xcode and platform frameworks\n* Cloud → AWS/GCP/Azure\n* Web → React, Angular, Vue\n\nAgentic AI is moving in the same direction. Each vendor is assembling its own “agent stack,” and engineers will eventually choose their agent platform the same way they choose a cloud provider or a frontend framework today.\n\nAnd it’s not just cloud vendors—open-source ecosystems are emerging too. Frameworks like [AutoGen](https://microsoft.github.io/autogen/stable/index.html) are already enabling multi-agent coordination and tooling without being tied to any specific cloud platform. I’ll explore this more deeply in a separate article, but it’s clear that both proprietary and open-source stacks will shape how the agent landscape evolves.\n\nWe’re still early in this shift, but the competition and cross-pollination that follow will shape how agent systems are built for years to come.\n\n### The Foundations Still Matter\n\nEven as agents automate more of the surface-level work, the underlying engineering remains critical. Everything demonstrated in the course - passing state between agents, controlling execution order, managing tools, and handling refinement loops - depends on reliable systems beneath the surface.\n\nCore skills still form the backbone - algorithms and data structures, database and API design distributed system fundamentals, reliability engineering, performance optimization etc.\n\nAgents can coordinate workflows, but they still rely on well-architected infrastructure, predictable interfaces, and resilient systems. The fundamentals aren’t being replaced - they remain the bedrock that makes large-scale agentic automation possible.\n\n## Final Thoughts\n\nOverall, the Agentic AI course by Google on the Kaggle platform was incredibly insightful. It gave me a practical understanding of how agentic systems operate, how the ecosystem is evolving, and what software development might look like in the near future.\n\nI walked away not just with new skills, but with a new perspective on how AI agents will transform workflows, industries, and our roles as developers.\n"}]},"__N_SSG":true}